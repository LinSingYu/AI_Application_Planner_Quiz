<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 應用規劃師測驗</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f1f5f9;
        }
        .fade-in {
            animation: fadeIn 0.4s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .option-btn:active {
            transform: scale(0.98);
        }
        /* 美化捲動條 */
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 10px;
        }
        .tab-active {
            border-bottom: 3px solid #4f46e5;
            color: #4f46e5;
        }
        /* 倒數計時動畫 */
        .pulse-soft {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .8; }
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div id="app" class="bg-white w-full max-w-2xl rounded-3xl shadow-2xl overflow-hidden transition-all duration-300 relative border border-gray-100">
        <!-- 頂部標題列 -->
        <div class="bg-indigo-700 p-5 text-white">
            <div id="header-content" class="flex justify-between items-center px-2">
                <h1 id="main-title" class="text-lg font-bold tracking-wider flex items-center gap-2">
                    AI 應用規劃師測驗系統
                </h1>
                <div id="header-nav"></div>
            </div>
        </div>

        <!-- 視圖容器 -->
        <div id="view-container" class="p-6 md:p-8 min-h-[500px]">
            <!-- 內容動態插入 -->
        </div>

        <!-- 自訂對話框(Modal)-->
        <div id="custom-modal" class="hidden fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 backdrop-blur-sm">
            <div class="bg-white rounded-xl shadow-2xl w-full max-w-sm overflow-hidden fade-in">
                <div class="p-6">
                    <h3 id="modal-title" class="text-lg font-bold text-gray-800 mb-2">確認操作</h3>
                    <p id="modal-content" class="text-gray-600">您確定要執行此操作嗎?</p>
                </div>
                <div class="bg-gray-50 p-4 flex justify-end gap-3">
                    <button id="modal-cancel" class="px-4 py-2 text-gray-600 hover:bg-gray-200 rounded-lg transition font-medium">取消</button>
                    <button id="modal-confirm" class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded-lg transition font-medium">確定刪除</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 類別定義
        const categories = ["科目一", "科目二"];

        // 考試日期定義
        const EXAM_DATE = new Date('2026-03-21');
        
        // 題庫資料(增加 category 欄位)
        let questionBank = [
            {
                category: "科目一",
                question: "在人工智慧系統的決策流程中，關於「人在迴圈上(Human-over-the-loop)」的敘述，下列何者正確?",
                options: ["人類參與每一次的 AI 決策流程。", 
                          "人類對 AI 的運行進行日常監督，必要時可立即介入修正或干預。", 
                          "AI 的所有判斷皆須經過人類審核。", 
                          "人類完全不參與 AI 運作。"
                        ],
                correct: 1,
                explanation: "Human-over-the-loop 強調的是監督機制，人類平時進行監督，必要時介入。"
            },
            {
                category: "科目一",
                question: "在機器學習中，若希望抑制模型學習過於複雜的模式以提升泛化能力，通常會使用下列哪種技術?",
                options: ["特徵交叉(Feature Cross)", 
                            "正規化(Normalization)", 
                            "正則化(Regularization)", 
                            "獨熱編碼(One-hot Encoding)"
                        ],
                correct: 2,
                explanation: "正則化(如 L1、L2)透過在損失函數中加入懲罰項來控制模型複雜度。"
            },
            {
                category: "科目一",
                question: "下列哪一項任務最適合使用「非監督式學習(Unsupervised Learning)」來處理?",
                options: ["根據已標記的醫療影像診斷疾病。", "根據歷史房價數據預測未來房價。", "根據消費者的購買行為將其自動分群。", "透過獎勵機制訓練電腦玩圍棋。"],
                correct: 2,
                explanation: "非監督式學習不依賴標籤，其核心在於發掘資料內在結構，例如分群。"
            },
            {
                category: "科目一",
                question: "關於鑑別式 AI 與生成式 AI 的差異，下列敘述何者正確?",
                options: ["生成式 AI 的主要目標是進行分類與預測。", "鑑別式 AI 側重於學習數據的聯合分佈以產生新樣本。", "鑑別式 AI 專注於學習數據特徵與標籤之間的邊界。", "生成式 AI 不會產生新的數據，僅能分析現有數據。"],
                correct: 2,
                explanation: "鑑別式 AI 專注於尋找分類邊界；生成式 AI 則專注於學習數據分佈並生成新內容。"
            },
            {
                category: "科目一",
                question: "某公司建置了基於檢索增強生成(RAG)的系統，其主要優勢為何?",
                options: ["可以完全取代大型語言模型的推理能力。", "允許模型在回答時檢索外部數據源中的即時資訊，減少幻覺並提升準確度。", "可以大幅縮短模型的推論與回應時間。", "不需要任何外部資料庫即可運作。"],
                correct: 2,
                explanation: "RAG 結合了檢索與生成，能補足模型知識的時效性與準確性。但因增加了檢索步驟，通常會比單純問 AI 稍微慢一些"
            },
            {
                category: "科目二",
                question: "關於 No Code 與 Low Code 平台的敘述，下列何者最準確?",
                options: ["Low Code 平台完全不需要任何程式設計知識。", "No Code 平台主要面向非技術使用者，透過拖拉元件即可開發應用。", "兩者都只能開發非常簡單的靜態網頁。", "Low Code 平台無法與企業現有的 CRM 或 ERP 系統整合。"],
                correct: 1,
                explanation: "No Code 適合非技術人員快速開發；Low Code 則結合視覺化工具與少量程式碼，適合開發者進行更複雜或客製化的功能，且通常具備系統整合能力。"
            },
            {
                category: "科目二",
                question: "在使用生成式 AI 解決數學或邏輯問題時，為了提升準確度，可以使用下列哪種提示工程(Prompt Engineering)技巧?",
                options: [" 要求 AI 用一句話簡短回答。", "思維鏈(Chain-of-Thought)，要求 AI 詳細列出每一個思考步驟。",
                            "提高溫度參數(Temperature)以增加隨機性。", " 僅提供關鍵字，不給予完整指令。"
                ],
                correct: 1,
                explanation: "Chain-of-Thought(CoT)能引導模型逐步推理，有效提升解決複雜邏輯或數學問題的準確性"
            },
            {
                category: "科目二",
                question: "企業導入生成式 AI 時，若希望驗證技術在真實業務場景中的可行性與效果，通常會進行哪一個階段?",
                options: ["概念驗證(Proof of Concept, POC)。", "大規模全面部署。", "採購硬體設備。", "員工全面裁員"],
                correct: 0,
                explanation: "POC 階段是透過小規模實驗測試，評估模型效能與業務融合度，確認具有商業價值後才進行擴大導入。"
            },
            {
                category: "科目二",
                question: "生成式 AI 可能會產生看似合理但實際上錯誤或虛構的資訊，這種現象稱為什麼?",
                options: ["過度擬合(Overfitting)。","梯度消失(Vanishing Gradient)。","幻覺(Hallucination)。","數據漂移(Data Drift)。"],
                correct: 2,
                explanation: " 幻覺(Hallucination)是大型語言模型常見的風險，指模型生成內容通順但缺乏真實依據或完全虛構。"
            },
            {
                category: "科目二",
                question: "根據 AI 導入的風險管理，若企業將資料去識別化後再進行處理，主要是為了降低哪一類風險?",
                options: ["隱私與資安風險。","模型效能不足風險。","運算資源不足風險。","員工抗拒風險。"],
                correct: 0,
                explanation: "資料去識別化(Data Anonymization)或差分隱私技術，主要是為了保護敏感個資，符合隱私法規(如 GDPR)並降低資安風險。"
            },
            {
                category: "科目一",
                question: "在訓練機器學習模型時，為了防止模型過度學習訓練數據中的雜訊和細節，導致其在未見過的新數據上表現不佳的「過擬合」(Overfitting)現象，下列哪種策略是有效的?",
                options: ["在損失函數中添加懲罰項，如L1或L2正則化","僅使用訓練資料來評估模型最終的效能","延長模型的訓練時間，直到訓練誤差趨近於零","增加模型的複雜度，例如增加神經網路的層數"],
                correct: 0,
                explanation: "在損失函數中添加懲罰項，如L1或L2正則化，可以有效防止模型過度學習訓練數據中的雜訊和細節，從而提升其泛化能力。"
            },
            {
                category: "科目一",
                question: "一個AI模型被訓練來辨識一封電子郵件是「垃圾郵件」還是「非垃圾郵件」。這個模型的首要任務是學習這兩類郵件之間的決策邊界。此模型屬於哪一種類型的AI?",
                options: ["鑑別式AI","分辨型AI","強化式AI","生成式AI"],
                correct: 0,
                explanation: "鑑別式AI的核心是「判斷」，生成式AI的核心是「創造」，這準確描述了兩者的根本差異。"
            },
            {
                category: "科目一",
                question: "在處理影像辨識任務時，哪一種深度學習模型因其特殊的結構(如卷積層與池化層)，能夠有效提取影像中的空間特徵(如邊緣、紋理)，而被廣泛應用?",
                options: ["卷積神經網路(Convolutional Neural Networks, CNN)","循環神經網路(Recurrent Neural Networks, RNN)","生成對抗網路(Generative Adversarial Networks, GAN)","變分自編碼器(Variational Autoencoders, VAE)"],
                correct: 0,
                explanation: "CNN的卷積層和池化層結構使其特別擅長捕捉影像的局部特徵和空間層次結構，是影像辨識的經典模型。"
            },
            {
                category: "科目一",
                question: "在資料前處理階段，資料清洗是提升資料品質的關鍵步驟。下列何者是處理資料中「遺缺值(Missing Value)」的常見方法?",
                options: ["使用平均值、中位數或眾數進行填補","檢測並修正拼寫錯誤等錯誤值","使用主成分分析(PCA)進行降維","將所有資料進行Z-score標準化"],
                correct: 0,
                explanation: "根據資料的特性，使用統計量(如平均值、中位數)來填補遺缺值是一種直接且常用的資料清洗策略。"
            },
            {
                category: "科目一",
                question: "生成對抗網路(GAN)是由哪兩個相互競爭的神經網路組成的?",
                options: ["生成器(Generator)和判別器(Discriminator)","代理(Agent)和環境(Environment)","卷積層(Convolutional Layer)和池化層(Pooling Layer)","編碼器(Encoder)和解碼器(Decoder)"],
                correct: 0,
                explanation: "GAN的核心思想是生成器努力生成逼真數據來「欺騙」判別器，而判別器則努力區分真實與生成數據。"
            },
            {
                category: "科目一",
                question: "隨機森林(Random Forest)模型相較於單一的決策樹模型，其主要的優勢是什麼?",
                options: ["透過集成學習降低過擬合風險，提升穩定性","訓練速度更快","能夠處理非結構化數據，如音訊","模型的可解釋性更高"],
                correct: 0,
                explanation: "透過構建多棵在不同數據子集上訓練的決策樹並進行投票或平均，隨機森林能夠有效減少單一決策樹易受數據雜訊影響而過擬合的問題。"
            },
            {
                category: "科目一",
                question: "在資料處理與分析的架構中，ETL流程代表什麼?",
                options: ["萃取(Extract)、轉換(Transform)、載入(Load)","加密(Encrypt)、傳輸(Transmit)、紀錄(Log)","探索(Explore)、測試(Test)、載入(Load)","評估(Evaluate)、轉換(Transform)、學習(Learn)"],
                correct: 0,
                explanation: "ETL是資料倉儲和資料處理中的一個核心流程，指的是從來源萃取資料，進行清洗和轉換，最後載入到目標資料庫或系統中。"
            },
            {
                category: "科目一",
                question: "循環神經網路(RNN)特別適合處理序列數據，但其訓練過程容易出現梯度消失或爆炸問題。下列哪一項是為了解決此問題而提出的改進版本?",
                options: ["長短期記憶網路(LSTM)","卷積神經網路(CNN)","生成對抗網路(GAN)","支援向量機(SVM)"],
                correct: 0,
                explanation: "LSTM透過引入遺忘門、輸入門和輸出門等門控機制，能有效捕捉長期依賴關係，並緩解梯度消失問題。"
            },
            {
                category: "科目一",
                question: "在機器學習流程中，為了避免模型在訓練資料上表現優異，但在測試資料上表現不佳的「過擬合」現象，下列何者是「不」常見的防範策略?",
                options: ["增加模型的層數與複雜度以捕捉更多特徵","透過隨機旋轉、翻轉等方式擴展訓練數據集(Data Augmentation)","在損失函數中添加L1或L2正則化(Regularization)","當模型在驗證集上的表現開始下降時，提早停止訓練(Early Stopping)"],
                correct: 0,
                explanation: "增加模型的複雜度反而更容易導致過擬合，因為模型有能力學習到訓練數據中更多的雜訊和不具泛化性的細節。"
            },
            {
                category: "科目一",
                question: "在機器學習的資料處理階段，使用 Z-score 標準化的主要目的是什麼?",
                options: ["將不同量級的特徵轉換到統一的範圍，消除尺度差異。","將所有數據映射到 0 到 1 的區間內。","減少資料集的維度以提高計算效率。","處理資料集中的遺缺值和重複值。"],
                correct: 0,
                explanation: "標準化的核心目的就是消除不同特徵因單位或量級不同所帶來的影響，使模型能公平對待所有特徵。"
            },
            {
                category: "科目一",
                question: "在非監督式學習中，K-均值聚類(K-Means)演算法的「K」值代表什麼意義?",
                options: ["使用者預先指定的群組(clusters)數量。","演算法需要迭代的總次數。","模型中每個群組的最小樣本數。","數據集中特徵(features)的數量。"],
                correct: 0,
                explanation: "在 K-Means 中，K 是一個超參數，代表使用者希望將數據集劃分為多少個群組。"
            },
            {
                category: "科目一",
                question: "下列何者最適合訓練電腦下圍棋、自動駕駛等動態重複地互動的問題? ",
                options: ["監督式學習(Supervised Learning)", "非監督式學習(Unsupervised Learning)", "半監督式學習(Semi-supervised Learning)", "強化學習(Reinforcement Learning)"],
                correct: 3,
                explanation: "強化學習(Reinforcement Learning, RL)是一種機器學習方法，"+
                "讓代理(Agent)透過與環境不斷互動，學習到一系列動作，以最大化累積獎勵。"+
                "這種學習方式非常適合用於訓練電腦在動態、複雜的環境中做出決策，例如下圍棋、自動駕駛等。"
            },
            {
                category: "科目一",
                question: "在分析一個地區的家庭年收入數據時，若數據中包含少數億萬富翁的極端高收入值，使用哪一個統計量來描述該地區的「典型」收入水平最能避免結果被扭曲?",
                options: ["中位數","平均數","眾樹","標準差"],
                correct: 0,
                explanation: "中位數是將所有數據排序後取中間值，因此它不受極端值的影響，能更好地反映資料的中心趨勢。"
            },
            {
                category: "科目一",
                question: "在機器學習模型訓練前，對不同特徵(例如年齡範圍為18-65，月收入範圍為25,000-250,000)進行數據標準化或正規化的主要目的是什麼?",
                options: ["消除不同特徵之間的尺度差異，以提升模型訓練效果","填補資料集中缺失的值","減少資料集的維度以加快計算速度","將連續型數據轉換為離散的類別。"],
                correct: 0,
                explanation: "標準化或正規化可以消除不同特徵之間的尺度差異，使模型訓練更穩定且收斂更快。"
            },
            {
                category: "科目一",
                question: "某個AI系統被設計來玩一款迷宮遊戲，它透過不斷嘗試不同的路徑，並根據「找到出口」或「撞到牆壁」等回饋來學習最佳策略。這種學習方式最符合哪一種類型的機器學習?",
                options: ["強化學習(Reinforcement Learning)","非監督式學習","監督式學習","深度學習(Deep Learning)"],
                correct: 0,
                explanation: "強化學習(Reinforcement Learning, RL)是一種機器學習方法，讓代理(Agent)透過與環境不斷互動，學習到一系列動作，以最大化累積獎勵。這種學習方式非常適合用於訓練電腦在動態、複雜的環境中做出決策，例如下圍棋、自動駕駛等。"
            },
            {
                category: "科目一",
                question: "在深度學習領域中，哪一種神經網路模型因其能夠記憶序列中先前的資訊，特別適合處理和分析如文本翻譯、語音辨識等具有時間序列特性的資料?",
                options: ["循環神經網路(RNN)","卷積神經網路(CNN)","支援向量機(SVM)","生成對抗網路(GAN)"],
                correct: 0,
                explanation: "循環神經網路(RNN)的結構中存在循環連結，因其具有記憶功能，能處理序列數據並捕捉時間上的依賴關係，特別適合處理如文本翻譯、語音辨識等具有時間序列特性的任務。"
            },
            {
                category: "科目一",
                question: "關於鑑別式AI(Discriminative AI)與生成式AI(Generative AI)的主要目標，下列敘述何者最為貼切?",
                options: ["鑑別式AI學習數據的潛在分佈以創造新內容，生成式AI學習數據的決策邊界以進行分類。","兩者都專注於數據分類，但生成式AI的準確率通常更高。","鑑別式AI專注於學習如何區分不同類別的數據，而生成式AI專注於學習如何產生新的數據。","鑑別式AI只能處理結構化數據，而生成式AI專為非結構化數據設計。"],
                correct: 2,
                explanation: "鑑別式AI的核心是「判斷」，生成式AI的核心是「創造」，這準確描述了兩者的根本差異。"
            },
            {
                category: "科目一",
                question: "關於AI的定義，下列敘述何者較為正確？",
                options: ["AI僅限於深度學習技術","AI包括各種技術，例如機器學習、專家系統等","AI系統只能在學術研究中應用","AI無法應用於金融領域"],
                correct: 1, //B
                explanation: "人工智慧(AI)就像是一個龐大的拼圖，由許多不同的技術碎片組成。這些技術各司其職，共同構成了我們所理解的人工智慧。(A)不限於深度學習，還有機器學習、演算法等。(C)不只限制於特定的研究、金融領域，在各領域都有許多AI的應用，如：醫學、交通等。"
            },
            {
                category: "科目一",
                question: "為了提升AI系統的透明性，下列哪種措施是適當的？ ",
                options: ["不需對外揭露任何有關AI系統的資訊","規劃透過發布報告、技術文件或網站揭露AI系統的相關資訊","僅對內部員工進行透明性說明","將所有AI系統資訊保密"],
                correct: 1, //B
                explanation: "透過定期或不定期發佈AI系統於各決策環節的決策流程，有助於提昇 AI 系統的透明性。"
            },
            {
                category: "科目一",
                question: "下列何者不適合做為資料分布估計？",
                options: ["直方圖(Histogram)","散布圖(Scatter plot)","雷達圖(Radar chart)","四分位數(Quartile)"],
                correct: 2, //C
                explanation: "雷達圖有幾個限制，無法直觀呈現機率密度：雷達圖主要用於比較不同個體在多個維度上的表現，而非呈現數據在每個維度上的分布情況。要了解數據在某個維度上的集中程度、分散程度等，需要更適合的圖形，如直方圖。"
            },
            {
                category: "科目一",
                question: "K-Means 聚類算法中，K代表什麼？",
                options: ["數據集中特徵的數量","數據集中樣本的數量","所需劃分的群組數量","迭代次數"],
                correct: 2, //C
                explanation: "K 在 K-Means 演算法中代表我們希望將數據分為幾個群組。K 值的選擇會直接影響最終的聚類結果，因此是一個非常重要的參數。"
            },
            {
                category: "科目一",
                question: "深度學習模型中，下列哪一項通常用來降低過擬合問題？",
                options: ["增加訓練數據量","增加模型的複雜度","增加學習率","增加正則化項"],
                correct: 3, //D
                explanation: "過擬合指的是模型過度學習訓練數據中的雜訊或特徵，導致在測試集上表現不佳。正則化是一種在模型中加入額外項來懲罰複雜模型的方法，常見的正則化項有L1正則化和L2正則化。增加正則化項可以使模型變得更簡單，降低過擬合的風險，提高模型的泛化能力。 "
            },
            {
                category: "科目一",
                question: "生成式人工智慧最核心的能力是什麼？",
                options: ["從大量數據中學習", "執行複雜的數學計算", "生成新的、原創的內容", "控制機器人"],
                correct: 2, //C
                explanation: "：生成式AI的最大特徵就是能夠生成全新的文本、圖像、音樂等內容。這與傳統的AI主要用於分析或預測已有數據不同。生成式 AI透過學習大量數據的模式，能產生出具有創造性的輸出。"
            },
            {
                category: "科目一",
                question: "下列哪項技術是生成式AI發展的重要基礎？",
                options: ["決策樹","神經網路","線性迴歸","貝氏分類"],
                correct: 1, //B
                explanation: "神經網路，尤其是深度學習模型，是生成式AI的基石。這些模型能夠學習數據中的複雜模式，並生成與訓練數據相似但又不完全相同的新的數據。其他選項如決策樹、線性迴歸和貝氏分類雖然也是機器學習的重要方法，但並不擅長生成新的內容。"
            },
            {
                category: "科目一",
                question: "關於AI，下列敘述何者較為正確？",
                options: ["AI僅限於深度學習技術","AI包括各種技術，例如機器學習、專家系統等","AI系統只能在學術研究中應用","AI無法應用於金融領域"],
                correct: 1, //B
                explanation: "：AI是一個廣泛的領域，涵蓋了多種技術，包括但不限於機器學習、深度學習、專家系統、自然語言處理和計算機視覺等。它不僅限於深度學習，也不僅侷限於學術研究，且已成功應用於金融、醫療、製造等多個領域。"
            },
            {
                category: "科目一",
                question: "在 AI治理中，下列何者是國際合作的重要性？",
                options: ["統一AI發展標準","避免AI技術的濫用","促進AI技術的轉移","以上皆是"],
                correct: 3, //D
                explanation: "：在AI治理中，國際合作的重要性包含多個方面，主要包括：統一AI發展標準，確保不同國家在技術應用上的一致性和互操作性。避免AI技術的濫用，透過跨國監管和政策協調減少倫理與安全風險。促進AI技術的轉移，幫助各國共享技術資源，縮小數位鴻溝。因此，以上選項都屬於國際合作的重要性。"
            },
            {
                category: "科目一",
                question: "關於K平均法(K-means)，下列敘述何者「不」正確？",
                options: ["希望找出k個互不交集的群集","不同的起始群集中心，可能會造成不同的分群結果","容易受雜訊與離群值(Outlier)影響其群集中心","可以處理類別型資料"],
                correct: 3,
                explanation: "K-means 演算法特性為隨機選取集群中心、依距離計算、各群質心為代表點、分割式分群、易受離群值影響、類別型資料集群方法。"
            },
            {
                category: "科目一",
                question: "在品質管理中，若一產品的生產過程中標準差顯著偏大，通常意味著什麼？",
                options: ["資料點高度集中，產品質量穩定","生產過程波動大，產品品質不穩定","資料無法反映產品實際狀況 ","中位數數值高，品質良率較高"],
                correct: 1,
                explanation: "標準差越大表示數據分散程度越高，在品質管理中意味著產品或過程波動大，進而產品品質不穩定，故答案為B。"
            },
            // {
            //     category: "科目一",
            //     question: "下列何者「並非」K平均數(k-means)集群法的特點？ ",
            //     options: ["原理相對其他集群法較為複雜","可結合其他方法，使用上較為彈性 ","在特定情況下，能將集群的任務處理得足夠好",")不適合非球形、數據密度變化大或有離群數據的集群問題"],
            //     correct: 1,
            //     explanation: ""
            // },
            {
                category: "科目一",
                question: "驗證性資料分析(Confirmatory Data Analysis, CDA)與探索性資料分析(Exploratory Data Analysis, EDA)相比，主要著重於下列哪一項？",
                options: ["對資料進行初步描述和視覺化","驗證先前生成的假設並進行深入挖掘","排除資料中的極端值以提高準確性","探索數據中潛在的模式和異常"],
                correct: 1,
                explanation: "驗證性資料分析的重點在於檢驗先前所提出的假設，通常採用分類、分群、相關性分析或預測模型等方法進行深入分析。"
            },
            {
                category: "科目一",
                question: "以下哪種情況下，使用中位數來描述資料的集中趨勢最為合適？",
                options: ["一組考試成績，大部分學生分數集中在80分左右","一組房屋價格數據，其中包含少數豪宅的極端高價 ","一組產品銷售量數據，每個產品的銷量差異不大 ","一組學生身高數據，呈現出常態分布"],
                correct: 1,
                explanation: "平均數：易受極端值影響。當資料中有極端值時，平均數可能會偏離資料的中心趨勢。中位數：不受極端值影響。它能更準確地反映資料的中心趨勢，特別是在資料分布不對稱或有極端值的情況下。眾數：表示資料中出現頻率最高的數值。"
            },
            {
                category: "科目一",
                question: "一組數據中，如果平均數小於中位數，那麼這組數據的分布可能是下列哪一種? ",
                options: ["對稱分布","正偏態分布","負偏態分布",")無法判斷 "],
                correct: 2,
                explanation: "對稱分布：平均數、中位數和眾數通常會接近。正偏態分布：資料的尾巴向右邊延伸，平均數會大於中位數。負偏態分布：資料的尾巴向左邊延伸，平均數會小於中位數。 "
            },
            {
                category: "科目一",
                question: "當我們進行一次假設檢定，得到的p值為0.03，顯著性水準設定為0.05，以下哪一個敘述是正確的？",
                options: ["我們有97%的信心拒絕虛無假設","我們有95%的信心拒絕虛無假設","我們無法拒絕虛無假設","我們有5%的機率犯型一錯誤"],
                correct: 1,
                explanation: "p值為0.03表示，在虛無假設為真的情況下，觀察到目前數據或更極端數據的機率是3%。換句話說，如果虛無假設是正確的，那麼得到這樣的結果是非常罕見的。顯著性水準設定為0.05表示，我們願意接受5%的風險來拒絕一個實際為真的虛無假設(即Type-I Error)。 比較p值和顯著性水準：由於0.03 < 0.05，因此我們拒絕虛無假設。這意味著，我們有95%的信心認為，觀察到的結果並非偶然，而是支持對立假設。 "
            },
            {
                category: "科目一",
                question: "一組資料中，若平均數大於中位數，則這組資料的分布可能是下列哪一種？ ",
                options: ["對稱分布","負偏態分布","正偏態分布 ","無法判斷"],
                correct: 2,
                explanation: "對稱分布：平均數、中位數和眾數通常會接近；負偏態分布：資料的尾巴向左邊延伸，平均數會小於中位數；正偏態分布：資料的尾巴向右邊延伸，平均數會大於中位數。"
            },
            {
                category: "科目一",
                question: "下列哪一個敘述關於四分位距(IQR)是正確的？ ",
                options: ["四分位距會受到極端值的影響","四分位距代表資料中所有數據的分散程度","四分位距是第三四分位數與第一四分位數的差 ","四分位距與平均數一樣，容易受到極端值影響"],
                correct: 2,
                explanation: "四分位距(IQR)是第三四分位數與第一四分位數的差，它代表資料中間50%數據的分散程度，不受極端值影響。"
            },
            {
                category: "科目一",
                question: "以下哪一種情況最適合用眾數來描述資料的集中趨勢？",
                options: ["一組學生身高資料，呈現出常態分布","一組產品銷售量資料，其中一種產品的銷量遠高於其他產品","一組考試成績資料，大部分學生的分數集中在80分左右","一組房屋價格資料，其中包含少數豪宅的極端高價 "],
                correct: 1,
                explanation: "眾數代表資料中出現頻率最高的數值。當資料中有一個或幾個數值出現的頻率明顯高於其他數值時，眾數能較好地反映資料的集中趨勢。當一種產品的銷量遠高於其他產品時，這個產品的銷量就是眾數。這代表大多數的銷售額來自於這個產品，使用眾數能更直接地反映出最受歡迎的產品。 "
            },
            {
                category: "科目一",
                question: "機器學習的三個核心要素是什麼？",
                options: ["數據、模型、損失函數","訓練集、測試集、驗證集 ","特徵工程、優化演算法、正則化 ","超參數調整、模型選擇、數據處理"],
                correct: 0,
                explanation: "機器學習的三個核心要素分別是數據(Data)、模型(Model)和損失函數(Loss Function)，其中數據提供基礎，模型學習數據的規律，損失函數用於評估預測的準確性並指導模型優化。"
            },
            {
                category: "科目一",
                question: "下列哪一項屬於監督式學習的特點？ ",
                options: ["數據集中包含標記訊息","僅需探索數據內部的結構 ","使用代理與環境互動進行學習","不需要驗證集來調整參數"],
                correct: 0,
                explanation: "監督式學習依賴有標記的數據集，透過學習輸入與輸出之間的映射關係來進行預測或分類。(B)是非監督式學習的特點，(C)是強化學習的特點。"
            },
            {
                category: "科目一",
                question: "機器學習模型過擬合的主要原因是什麼？",
                options: ["模型的複雜度不足","訓練數據樣本過多 ","模型過度學習數據中的雜訊","使用過於簡單的損失函數 "],
                correct: 2,
                explanation: "過擬合通常是由於模型學習了訓練數據中的雜訊或特定模式，導致模型對測試數據泛化能力不足。"
            },
            {
                category: "科目一",
                question: "交叉驗證的主要目的是什麼？",
                options: ["提高模型的訓練速度","驗證數據是否線性可分 ","減少模型的過擬合風險","測試模型的容錯能力"],
                correct: 2,
                explanation: "交叉驗證透過多次分割數據進行訓練和測試，有助於評估模型的穩健性並降低過擬合的可能性。"
            },
            {
                category: "科目一",
                question: "機器學習的梯度下降演算法主要用於什麼？",
                options: ["減少模型的計算複雜度","優化模型參數以最小化損失函數 ","減少數據中的雜訊干擾 ","增強數據特徵的表示能力"],
                correct: 1,
                explanation: "梯度下降演算法是一種優化方法，透過計算損失函數相對參數的偏導數，調整模型參數使損失函數值逐漸減小。"
            },
            {
                category: "科目一",
                question: "線性迴歸模型最適合解決哪種類型的問題？",
                options: ["圖像分類","銷售額預測 ","聚類分析 ","遊戲策略學習 "],
                correct: 1,
                explanation: "線性迴歸是一種典型的迴歸模型，用於解決輸出為連續值的問題，如預測銷售額或房價。"
            },
            {
                category: "科目一",
                question: "決策樹的最大優勢是什麼？",
                options: ["適合大規模數據的訓練 ","具有良好的可解釋性","不需要進行數據標準化","適用於圖像生成任務 "],
                correct: 1,
                explanation: "決策樹的分支結構清晰，便於直觀解釋，因此廣泛用於需要高可解釋性的任務，如醫學診斷或風險評估。"
            },
            {
                category: "科目一",
                question: "神經網路與傳統機器學習模型的主要區別是什麼？",
                options: ["神經網路無法處理非線性數據","神經網路透過多層結構學習複雜特徵","神經網路只適用於迴歸問題","神經網路不需要大量數據支持"],
                correct: 1,
                explanation: "神經網路具有多層結構，能夠從數據中提取高層次特徵，適合處理複雜的非線性問題，例如圖像分類和語音辨識。"
            },
            {
                category: "科目一",
                question: "下列關於生成對抗網路(GAN)的描述正確的是哪一項？",
                options: ["GAN僅用於分類問題","GAN由生成器和鑑別器組成","GAN的結果始終高度可解釋","GAN不能生成高品質的數據"],
                correct: 1,
                explanation: "生成對抗網路(GAN)由生成器和鑑別器組成，透過對抗學習生成高品質的數據，應用於圖像生成、文本生成等任務。"
            },
            {
                category: "科目一",
                question: "隨機森林(Random Forest)改進了單一決策樹的缺陷，主要透過什麼方法實現？",
                options: ["使用核函數映射高維空間","集成多棵隨機生成的決策樹並投票","增加模型參數以減少偏差","採用生成模型替代分類器"],
                correct: 1,
                explanation: "隨機森林是決策樹的集成演算法，透過構建多棵隨機決策樹並對其結果進行投票，有效降低了過擬合的風險。"
            },
            {
                category: "科目一",
                question: "未命名的問題公司內部的經營數據分散在多個舊有系統，格式不一且難以管理，導致決策者無法取得一致的分析結果。問題：AI技術如何具體協助該公司改善資料管理困難？",
                options: ["透過資料整合、數據清洗和視覺化","增加資料的複雜性以提升分析深度","減少資料的收集以簡化管理","將資料分散儲存在更多地方以分散風險"],
                correct: 0,
                explanation: "AI技術可以透過整合多個來源的資料、清洗不一致的數據並提供視覺化工具，幫助企業建立統一且易於理解的數據視圖。"
            },
            {
                category: "",
                question: "",
                options: ["","","",""],
                correct: 0,
                explanation: ""
            },
            {
                category: "",
                question: "",
                options: ["","","",""],
                correct: 0,
                explanation: ""
            },
            //////////
            // /////// 以下內容我不確定試科目一還是科目二
            {
                category: "",
                question: "在處理一個包含使用者評論、產品圖片和銷售紀錄表格的資料庫時，這三種資料分別最貼切地對應到哪三種類型的資料結構?",
                options: ["非結構化資料、非結構化資料、結構化資料","半結構化資料、非結構化資料、結構化資料","結構化資料、半結構化資料、非結構化資料","非結構化資料、結構化資料、半結構化資料"],
                correct: 0,
                explanation: "使用者評論和圖片缺乏固定的格式，屬於非結構化資料；而銷售紀錄表格具有明確的行列定義，是典型的結構化資料。"
            },
            {
                category: "",
                question: "某公司發現上季度的銷售額突然下降，分析師為了探究「為什麼會發生」，從總銷售額開始，逐層深入到地區、產品類別，最後到特定門市。這種分析方法屬於哪一種類型?",
                options: ["探索性分析","診斷性分析","預測性分析","敘述性分析"],
                correct: 1,
                explanation: "診斷性分析是用來探究問題發生的原因，透過深入分析數據找出導致異常的關鍵因素。"
            },
            {
                category: "",
                question: "生成對抗網路(GAN)是透過兩個神經網路的相互競爭來學習。其中，生成器(Generator)的目標是什麼?",
                options: ["生成與真實數據相似的新樣本","最小化模型在標記數據上的預測錯誤","準確地將輸入數據分類","將高維度數據壓縮到低維度空間"],
                correct: 0,
                explanation: "生成器的任務是學習真實數據的分佈，並產生讓判別器無法分辨真偽的新樣本。"
            },
            
            {
                category: "",
                question: "",
                options: ["","","",""],
                correct: 0,
                explanation: ""
            },
        ];

        let state = {
            currentIndex: 0,
            score: 0,
            userAnswers: [],
            sessionQuestions: [],
            manageCategory: categories[0],
            isAnswered: false, // 是否已回答當前題目
            selectedIdx: null  // 當前選擇的選項
        };

        window.onload = () => renderHome();

        // 工具：計算剩餘天數
        function getDaysRemaining() {
            const now = new Date();
            const diffTime = EXAM_DATE - now;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return diffDays > 0 ? diffDays : 0;
        }
        
        // 工具：洗牌
        function shuffleArray(array){
            for(let i = array.length - 1; i > 0; i--){
                const j = Math.floor(Math.random()*(i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // 更新頂部按鈕
        function updateHeader(view){
            const nav = document.getElementById('header-nav');
            const title = document.getElementById('main-title');
            
            if (view === 'quiz') {
                title.innerText = "進行測驗中";
                nav.innerHTML = `
                    <button onclick="confirmExit()" class="text-xs bg-white/20 hover:bg-white/30 px-3 py-1.5 rounded-lg transition border border-white/20">
                        退出
                    </button>
                `;
            } else if(view === 'manage'){
                title.innerText = "題庫管理中心";
                nav.innerHTML = `
                    <button onclick="renderHome()" class="text-xs bg-white/20 hover:bg-white/30 px-3 py-1.5 rounded-lg transition border border-white/20">
                        返回首頁
                    </button>
                `;
            } else {
                title.innerText = "AI 應用規劃師測驗系統";
                nav.innerHTML = `
                    <button onclick="renderManage()" class="text-xs bg-white/20 hover:bg-white/30 px-3 py-1.5 rounded-lg transition border border-white/20">
                        管理題庫
                    </button>
                `;
            }
        }

        function confirmExit() {
            const modal = document.getElementById('custom-modal');
            document.getElementById('modal-title').innerText = "退出測驗";
            document.getElementById('modal-content').innerText = "確定要退出目前的測驗嗎？進度將不會被保存。";
            const confirmBtn = document.getElementById('modal-confirm');
            confirmBtn.innerText = "確定退出";
            modal.classList.remove('hidden');

            const close = () => modal.classList.add('hidden');
            document.getElementById('modal-cancel').onclick = close;
            confirmBtn.onclick = () => { close(); renderHome(); };
        }

    // --- 視圖：首頁 ---
        function renderHome() {
            updateHeader('home');
            const container = document.getElementById('view-container');
            const daysLeft = getDaysRemaining();

            container.innerHTML = `
                <div class="py-2 fade-in">
                    <div class="mb-8 p-4 bg-gradient-to-r from-amber-50 to-orange-50 border border-amber-200 rounded-2xl flex items-center justify-between shadow-sm pulse-soft">
                        <div class="flex items-center gap-3">
                            <div class="bg-amber-100 p-2 rounded-lg text-amber-600">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2-2v12a2 2 0 002 2z" />
                                </svg>
                            </div>
                            <div>
                                <p class="text-sm font-medium text-amber-800">初級 AI 應用規劃師 考試倒數</p>
                                <p class="text-xs text-amber-600 font-bold tracking-wide">考試日期：2026 / 03 / 21</p>
                            </div>
                        </div>
                        <div class="text-right">
                            <span class="text-2xl font-black text-amber-700">${daysLeft}</span>
                            <span class="text-xs font-bold text-amber-600 ml-0.5">DAYS</span>
                        </div>
                    </div>

                    <div class="text-center py-4">
                        <h2 class="text-2xl font-black text-gray-800 mb-2">請選擇測驗科目</h2>
                        <p class="text-gray-500 mb-8">每題作答後將即時提供答案回饋</p>
                        
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-8">
                            ${categories.map(cat => {
                                const count = questionBank.filter(q => q.category === cat).length;
                                return `
                                    <button onclick="startQuiz('${cat}')" class="group p-6 bg-white border-2 border-gray-100 rounded-2xl hover:border-indigo-500 hover:bg-indigo-50 transition-all text-left shadow-sm">
                                        <div class="flex justify-between items-center mb-2">
                                            <span class="text-indigo-600 font-bold">${cat}</span>
                                            <span class="text-xs bg-indigo-100 text-indigo-600 px-2 py-0.5 rounded-full">${count} 題</span>
                                        </div>
                                        <p class="hidden text-sm text-gray-400">雙重隨機洗牌，附即時解析</p>
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // --- 功能：測驗邏輯 ---
        function startQuiz(category) {
            const pool = questionBank.filter(q => q.category === category);
            if (pool.length === 0) {
                alert('該科目目前沒有題目。');
                return;
            }

            let shuffledPool = shuffleArray([...pool]);

            state.sessionQuestions = shuffledPool.map(q => {
                let meta = q.options.map((t, i) => ({ text: t, isCorrect: i === q.correct }));
                shuffleArray(meta);
                return {
                    category: q.category,
                    question: q.question,
                    options: meta.map(m => m.text),
                    correct: meta.findIndex(m => m.isCorrect),
                    explanation: q.explanation || "無詳細解析。"
                };
            });

            state.currentIndex = 0;
            state.score = 0;
            state.userAnswers = [];
            state.isAnswered = false;
            state.selectedIdx = null;
            updateHeader('quiz');
            renderQuestion();
        }

        function renderQuestion() {
            const container = document.getElementById('view-container');
            const q = state.sessionQuestions[state.currentIndex];
            const progress = ((state.currentIndex + 1) / state.sessionQuestions.length) * 100;

            container.innerHTML = `
                <div class="fade-in space-y-6">
                    <div class="flex justify-between items-end">
                        <div>
                            <span class="text-xs font-bold text-indigo-500 uppercase tracking-widest">${q.category}</span>
                            <h2 class="text-xl font-bold text-gray-800 mt-1">第 ${state.currentIndex + 1} 題</h2>
                        </div>
                        <span class="text-xs text-gray-400 font-bold">${state.currentIndex + 1} / ${state.sessionQuestions.length}</span>
                    </div>
                    
                    <div class="w-full bg-gray-100 h-2 rounded-full overflow-hidden">
                        <div class="bg-indigo-600 h-full transition-all duration-500" style="width: ${progress}%"></div>
                    </div>

                    <p class="text-lg font-medium text-gray-700 leading-relaxed min-h-[60px]">${q.question}</p>

                    <div class="grid grid-cols-1 gap-3">
                        ${q.options.map((opt, i) => {
                            let btnClass = "border-gray-100 bg-white hover:border-indigo-500 hover:bg-indigo-50";
                            let icon = `<span class="w-10 h-10 rounded-xl bg-gray-50 text-gray-400 flex items-center justify-center mr-4 font-black transition-colors group-hover:bg-indigo-600 group-hover:text-white">${String.fromCharCode(65 + i)}</span>`;
                            
                            if (state.isAnswered) {
                                if (i === q.correct) {
                                    // 正確選項變綠
                                    btnClass = "border-green-500 bg-green-50";
                                    icon = `<span class="w-10 h-10 rounded-xl bg-green-500 text-white flex items-center justify-center mr-4"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path></svg></span>`;
                                } else if (i === state.selectedIdx) {
                                    // 使用者選錯變紅
                                    btnClass = "border-red-500 bg-red-50";
                                    icon = `<span class="w-10 h-10 rounded-xl bg-red-500 text-white flex items-center justify-center mr-4"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"></path></svg></span>`;
                                } else {
                                    btnClass = "border-gray-100 bg-gray-50 opacity-60";
                                    icon = `<span class="w-10 h-10 rounded-xl bg-gray-200 text-gray-400 flex items-center justify-center mr-4 font-black">${String.fromCharCode(65 + i)}</span>`;
                                }
                            }

                            return `
                                <button onclick="handleAnswer(${i})" ${state.isAnswered ? 'disabled' : ''} class="option-btn group text-left p-4 border-2 rounded-2xl transition-all flex items-center ${btnClass} shadow-sm">
                                    ${icon}
                                    <span class="text-gray-700 font-medium">${opt}</span>
                                </button>
                            `;
                        }).join('')}
                    </div>

                    <!-- 即時解析區域 -->
                    <div id="feedback-area" class="${state.isAnswered ? 'block' : 'hidden'} fade-in space-y-4 pt-4">
                        <div class="p-5 bg-indigo-50 rounded-2xl border border-indigo-100">
                            <h4 class="font-bold text-indigo-700 mb-2 flex items-center gap-2">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a8 8 0 100 16 8 8 0 000-16zm1 11H9v-2h2v2zm0-4H9V5h2v4z"></path></svg>
                                題目解析
                            </h4>
                            <p class="text-sm text-gray-700 leading-relaxed">${q.explanation}</p>
                        </div>
                        <button onclick="nextQuestion()" class="w-full bg-indigo-600 text-white py-4 rounded-2xl font-bold hover:bg-indigo-700 transition shadow-lg shadow-indigo-200 flex items-center justify-center gap-2">
                            ${state.currentIndex < state.sessionQuestions.length - 1 ? '下一題' : '查看最終結果'}
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                        </button>
                    </div>
                </div>
            `;
        }

        function handleAnswer(idx) {
            if (state.isAnswered) return;
            
            state.isAnswered = true;
            state.selectedIdx = idx;
            state.userAnswers.push(idx);
            
            const q = state.sessionQuestions[state.currentIndex];
            if (idx === q.correct) {
                state.score++;
            }
            
            renderQuestion(); // 重新渲染以顯示回饋
        }

        function nextQuestion() {
            if (state.currentIndex < state.sessionQuestions.length - 1) {
                state.currentIndex++;
                state.isAnswered = false;
                state.selectedIdx = null;
                renderQuestion();
            } else {
                renderResult();
            }
        }

        function renderResult() {
            updateHeader('home');
            const container = document.getElementById('view-container');
            const total = state.sessionQuestions.length;
            const score = Math.round((state.score / total) * 100);
            
            container.innerHTML = `
                <div class="fade-in space-y-10 py-6 text-center">
                    <div>
                        <p class="text-xs font-bold text-gray-400 uppercase tracking-widest mb-2">Quiz Result</p>
                        <h2 class="text-8xl font-black text-indigo-600">${score}</h2>
                        <p class="text-gray-500 font-medium mt-2">答對 ${state.score} 題 / 共 ${total} 題</p>
                    </div>

                    <div class="bg-gray-50 p-6 rounded-3xl border border-gray-100 text-left">
                        <h3 class="font-bold text-gray-800 mb-4 flex items-center gap-2">
                            <span class="w-1.5 h-6 bg-indigo-600 rounded-full"></span>
                            表現評價
                        </h3>
                        <p class="text-gray-600 leading-relaxed">
                            ${score === 100 ? '非常優秀！您已經完全掌握了此科目的核心知識點。' : 
                              score >= 60 ? '表現不錯！建議針對答錯的部分再進行加強。' : 
                              '還需要多加努力，建議回到管理頁面重新檢閱題庫內容。'}
                        </p>
                    </div>

                    <div class="flex flex-col sm:flex-row gap-4">
                        <button onclick="renderHome()" class="flex-1 bg-indigo-600 text-white py-4 rounded-2xl font-bold hover:bg-indigo-700 transition shadow-lg shadow-indigo-100">
                            回到科目選擇
                        </button>
                    </div>
                </div>
            `;
        }
        
        // --- 視圖：題庫管理 ---
        function renderManage() {
            updateHeader('manage');
            const container = document.getElementById('view-container');
            const filteredQuestions = questionBank.filter(q => q.category === state.manageCategory);

            container.innerHTML = `
                <div class="fade-in space-y-6">
                    <div class="flex border-b border-gray-200">
                        ${categories.map(cat => `
                            <button onclick="switchManageTab('${cat}')" class="flex-1 py-3 font-bold transition-all ${state.manageCategory === cat ? 'tab-active' : 'text-gray-400 hover:text-gray-600'}">
                                ${cat}
                            </button>
                        `).join('')}
                    </div>

                    <div class="bg-gray-50 p-5 rounded-2xl border border-gray-200 space-y-4">
                        <h3 class="font-bold text-gray-700">新增題目到「${state.manageCategory}」</h3>
                        <input id="new-q-text" type="text" placeholder="題目內容" class="w-full p-3 border rounded-xl outline-none focus:ring-2 focus:ring-indigo-500 border-gray-300">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <input id="opt-0" type="text" placeholder="選項 A" class="p-2 border rounded-lg border-gray-300">
                            <input id="opt-1" type="text" placeholder="選項 B" class="p-2 border rounded-lg border-gray-300">
                            <input id="opt-2" type="text" placeholder="選項 C" class="p-2 border rounded-lg border-gray-300">
                            <input id="opt-3" type="text" placeholder="選項 D" class="p-2 border rounded-lg border-gray-300">
                        </div>
                        <div class="flex flex-wrap items-center gap-4">
                            <select id="correct-idx" class="p-2 border rounded-lg border-gray-300 text-sm">
                                <option value="0">正確答案：A</option>
                                <option value="1">正確答案：B</option>
                                <option value="2">正確答案：C</option>
                                <option value="3">正確答案：D</option>
                            </select>
                            <button onclick="addQuestion()" class="flex-1 bg-green-600 text-white py-2 rounded-xl font-bold hover:bg-green-700 transition shadow-md">加入題庫</button>
                        </div>
                        <textarea id="new-q-exp" placeholder="請輸入本題詳細解析內容..." class="w-full p-3 border rounded-lg border-gray-300 text-sm h-24 outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
                    </div>

                    <div class="space-y-3">
                        <h3 class="font-bold text-gray-700 px-1">現有題目 (${filteredQuestions.length})</h3>
                        <div class="max-h-[250px] overflow-y-auto space-y-2 pr-2">
                            ${filteredQuestions.length === 0 ? '<p class="text-center text-gray-400 py-8 italic">此科目尚無題目</p>' : 
                                filteredQuestions.map((q, idx) => {
                                    const originalIdx = questionBank.findIndex(item => item === q);
                                    return `
                                        <div class="bg-white p-4 border border-gray-100 rounded-xl flex justify-between items-start hover:shadow-sm transition">
                                            <div class="flex-1 pr-4 text-sm">
                                                <p class="font-bold text-gray-800 leading-relaxed">${idx + 1}. ${q.question}</p>
                                                <p class="text-indigo-500 mt-2 font-medium">正確答案：${q.options[q.correct]}</p>
                                            </div>
                                            <button onclick="deleteQuestion(${originalIdx})" class="text-gray-300 hover:text-red-500 transition p-1">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                                </svg>
                                            </button>
                                        </div>
                                    `;
                                }).join('')
                            }
                        </div>
                    </div>
                </div>
            `;
        }

        function switchManageTab(cat){
            state.manageCategory = cat;
            renderManage();
        }

        function addQuestion() {
            const q = document.getElementById('new-q-text').value.trim();
            const exp = document.getElementById('new-q-exp').value.trim();
            const opts = [
                document.getElementById('opt-0').value.trim(),
                document.getElementById('opt-1').value.trim(),
                document.getElementById('opt-2').value.trim(),
                document.getElementById('opt-3').value.trim()
            ];
            const correct = parseInt(document.getElementById('correct-idx').value);

            if (!q || opts.some(o => !o)) {
                alert('請填寫完整題目與四個選項內容');
                return;
            }

            questionBank.push({
                category: state.manageCategory,
                question: q,
                options: opts,
                correct: correct,
                explanation: exp || "無詳細解析。"
            });

            renderManage();
        }

        function deleteQuestion(originalIndex) {
            const modal = document.getElementById('custom-modal');
            document.getElementById('modal-title').innerText = "確認刪除題目";
            document.getElementById('modal-content').innerText = "題目一旦刪除將無法復原，確定要執行嗎？";
            const confirmBtn = document.getElementById('modal-confirm');
            confirmBtn.innerText = "確定刪除";
            modal.classList.remove('hidden');

            const close = () => modal.classList.add('hidden');
            document.getElementById('modal-cancel').onclick = close;
            confirmBtn.onclick = () => { 
                questionBank.splice(originalIndex, 1);
                renderManage();
                close(); 
            };
        }
    </script>
</body>
</html>
